# Django1 README

## Some of the fundamental principles

1. Modularization: the Django apps are composed by diverse modules (called "apps"), each one with it own specific responsability, which make the maintenance and organization of the code easier, as well as its reuse.

2. MTV pattern (Model-Template-View): 3 layers architecture; Models represent the data structure (database mapping), Views are responsible to the logic (business rules) and Templates take care of the data presentation (HTML rendered in the browser)

3. ORM (Object-Relational Mapping): Django itself provides an ORM that allows the use of Python code to perform database queries and manipulations, making development faster by eliminating the need to write SQL queries manually.

4. Ready-to-use admin interface: The automatic admin interface offered by Django reads metadata in the models to provide an interface that allows managing your data - adding, editing, and deleting database records, for example, without the need to write code.

5. URL Routing: Django uses a simple mapping system between URL patterns of HTTP requests and the functions that define their corresponding views, facilitating not only code organization but also maintenance and expansion of the application.

6. Authentication: Django comes with a complete and easy-to-use authentication system that handles user accounts, groups, permissions, and cookie-based sessions, allowing the creation of websites where users can create accounts and log in/out securely.

7. Security: Django has several built-in features to help protect applications against common vulnerabilities, such as SQL injection, CSRF (Cross-Site Request Forgery), and XSS (Cross-Site Scripting), for example.


## Commands:

- mkdir "folder" && cd "folder"
- python3 -m venv .venv && source .venv/bin/activate
- pip install django
- django-admin startproject "project_name" .        ### the "." means actual directory (/"folder")
- python3 manage.py runserver


## Files Structure:

```
ecommerce
â”‚Â Â  â”œâ”€â”€ .venv
â”‚Â Â  â”œâ”€â”€ ecommerce
â”‚Â Â  Â Â  â”œâ”€â”€ __pycache__
â”‚Â Â  Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  Â Â  â”œâ”€â”€ asgi.py
â”‚Â Â  Â Â  â”œâ”€â”€ settings.py
â”‚Â Â  Â Â  â”œâ”€â”€ urls.py
â”‚Â Â  Â Â  â””â”€â”€ wsgi.py
â””â”€â”€ db.sqlite3
â””â”€â”€ manage.py
```
---
### Description:
- ***manage.py***: this is the file used internally when running Django commands - like the runserver command we ran earlier.
- ***init.py***: file that indicates the directory is a Python package - we already used this file back in section 1, remember?
- ***asgi.py***: configuration file for ASGI (Asynchronous Server Gateway Interface), which is the protocol used by Django for communication between web servers and web applications to handle asynchronous and real-time requests.
- ***settings.py***: project configuration file, which contains all the Django settings for the project. This is where we configure, for example, the database to be used, the default language of the application, etc. We will take a closer look at this file shortly.
- ***urls.py***: project routing configuration file.
- ***wsgi.py***: configuration file for WSGI (Web Server Gateway Interface), which is the protocol used by Django for communication between web servers and web applications to handle HTTP requests.
- ***pycache***: directory that contains files automatically generated by Python to optimize module loading.

### settings.py:

This is the file that gathers the main configurations of the project, with many of these settings already defined with default values.

- ***SECRET_KEY***: is a security key that Django uses to encrypt sensitive data, such as user passwords, for example. It comes with a default value but is explicitly given as insecure, so it is recommended to replace it with a strong custom key, especially in production environments.
- ***DEBUG***: is a boolean that indicates whether debug mode is enabled or not. During development, having this mode enabled is very useful to help identify and fix bugs; the default value of this variable is true for this reason. However, it can pose some security vulnerabilities, such as exposing sensitive project information, which is undesirable if shown to a user. Therefore, it is important to have it disabled when the project is in production.
- ***ALLOWED_HOSTS***: is a list of domain names, subdomains, or IP addresses that Django allows to access the project. You can use the value '*', if you want to grant access to everyone, or define a list with the groups that will have access to the project, for example, ['example.com', 'subdomain.example.com', '192.168.1.1'].
- ***INSTALLED_APPS***: is a list of apps that will be included in the Django project. Some are installed by default, but the apps you create for the project can also be part of this variable. We will see how to do this soon! ðŸ¤©
- ***MIDDLEWARE***: is a list of middlewares that Django uses to perform certain tasks such as user authentication middleware. Its logic is similar to that of Express Middlewares, but we will go into detail about them in the next section.
- ***TEMPLATES***: is a list of directories where Django will look for HTML templates.
- ***DATABASES***: is the project's database configuration. Since Django comes with SQLite installed by default, it already includes the SQLite configuration, but we can switch to others.
- ***LANGUAGE_CODE***: is the default language setting of the project. By default, it comes with English, but we can change it to any other language.
---
### Using other databases:

1. Delete "db.sqlite3" file.
2. Change "DATABASES" variable at "settings.py" file.
    ```
    Example (using MySQL through Docker):
    -   DATABASES = {
            'default': {
                'ENGINE': 'django.db.backends.mysql',
                'NAME': 'ecommerce_database',
                'USER': 'root',
                'PASSWORD': 'password',
                'HOST': '127.0.0.1',
                'PORT': '3306',
            }
        }
    ```
3. Create "database" folder, then "01_create_database.sql" file.
    ```
    Example (script in "01_create_database.sql"):
    -   CREATE DATABASE IF NOT EXISTS ecommerce_database;
        USE ecommerce_database;
    ```
4. Create "Dockerfile" in the project root folter.
    ```
    Example (script in "Dockerfile"):
    -   FROM mysql:8.0.32
        ENV MYSQL_ROOT_PASSWORD password
        COPY ./database/01_create_database.sql /docker-entrypoint-initdb.d/data.sql01
    ```
5. Run "docker build -t ecommerce-db ." at the project root terminal.
6. Run "docker run -d -p 3306:3306 --name=ecommerce-mysql-container -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=ecommerce_database ecommerce-db"
    ```
    Explanation:

    1. docker run: This command is used to create and start a new container from a specified Docker image.
    2. -d: This flag stands for "detached mode." It runs the container in the background and prints the container ID, allowing you to continue using the terminal.
    3. -p 3306:3306: This option maps port 3306 on your host machine to port 3306 on the container. The format is host_port:container_port. MySQL typically runs on port 3306, so this allows you to access the MySQL database inside the container through port 3306 on your host machine.
    4. --name=ecommerce-mysql-container: This flag assigns a name to the container. In this case, the container is named ecommerce-mysql-container. Naming the container makes it easier to reference in future Docker commands.
    5. -e MYSQL_ROOT_PASSWORD=password: This environment variable sets the root password for the MySQL server inside the container. The -e flag allows you to pass environment variables to the container.
    6. -e MYSQL_DATABASE=ecommerce_database: This environment variable specifies the name of a database to be created when the MySQL server starts. In this case, a database named ecommerce_database will be created.
    7. ecommerce-db: This is the name of the Docker image from which the container is created. You must have previously built or pulled this image.



    Putting it all together, this command will:

    1. Run a new container in the background using the ecommerce-db image.
    2. Map the host's port 3306 to the container's port 3306, allowing you to connect to the MySQL server from the host machine.
    3. Name the container ecommerce-mysql-container.
    4. Set the MySQL root user's password to password.
    5. Create a new database named ecommerce_database within the MySQL server.
    ```
7. Run "python3 manage.py migrate"

---
### Creating Model, Migration and populating the new Table:

With the database already created and configured:
1. At "root/folder1/settings.py" (in this case "ecommerce/ecommerce/settings.py"):
```
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
+    "products",
]
```
2. Run "django-admin startapp products" to start create the "app". (Attention: STARTAPP instead of STARTPROJECT).<br>
The file structure should now look like this:
```
ecommerce
â”‚Â Â  â”œâ”€â”€ .venv
â”‚       â””â”€â”€ ...
â”‚Â Â  â”œâ”€â”€ ecommerce
â”‚       â””â”€â”€ ...
â”‚Â  Â â”œâ”€â”€ products
â”‚       â””â”€â”€ ...
â””â”€â”€ db.sqlite3
â””â”€â”€ manage.py
```
3. Inside the "products" folder, in the "models.py" file, create the script to generate the Model:
```
from django.db import models


class Product(models.Model):
    name = models.CharField(max_length=100)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    amount = models.IntegerField(default=0)
    description = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    image = models.ImageField(
        upload_to="media/products", null=True, blank=True
    )
```
4. If you got an error in the terminal ("products.Product.image: (fields.E210)..."), run "python3 -m pip install Pillow" then "python3 manage.py runserver".
5. Run:<br>
    - "python3 manage.py makemigrations" (instructions for creating the table in the database)<br>
    then run:<br>
    - "python3 manage.py migrate" (executes the migration instructions to actually create the table).
6. Run:<br>
    "python3 manage.py shell" (to access the terminal)<br>
    then run the script:<br>
    ```
    new_product = Product(name="NEW PRODUCT", price=10.0, amount=5, description="Brand new product!")<br>
    new_product.save().
    ```

---
### Creating a SuperUser:

On the project root terminal:
1. Run "python3 manage.py createsuperuser".<br>
    You'll need to set:
    - username
    - email
    - password (and confirm)<br>
    Then you'll be able to access the "localhost.8000/admin" route.
2. Register the already created Models in the "admin.py" file. ("ecommerce/products/admin.py")<br>
    The code should look like this:
```
    from django.contrib import admin
    from products.models import Product
    from products.models import Customer


    admin.site.register(Product)
    admin.site.register(Customer)
```
3. (Optional) Change the Model to render the name of the product instead of "Product object (n)".<br>
    The updated code should look like this:
```
    from django.contrib import admin
    from products.models import Product
    from products.models import Customer


    admin.site.register(Product)
    admin.site.register(Customer)
    admin.site.site_header = "E-commerce Admin: testing Django for the first time"

```